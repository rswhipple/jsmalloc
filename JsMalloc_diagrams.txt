
+--------------------------------------------+
|                                            |
|                Application                 |
|                                            |
+--------------------------------------------+
                |         ^
                |         |
                v         |
+--------------------------------------------+
|               Frontend Cache               |
|                                            |
|  +--------------------------------------+  |
|  |                                      |  |
|  |          Fast Cache Array            |  |
|  |                                      |  |
|  |  +-------------------------------+   |  |
|  |  | - Tiny Allocation (min to 64) |   |  |
|  |  | t_tiny_chunk** fast_cache     |   |  |
|  |  | size_t fcache_size            |   |  |
|  |  +-------------------------------+   |  |
|  |                                      |  |
|  |          Unsorted Cache              |  |
|  |                                      |  |
|  |  +-------------------------------+   |  |
|  |  | t_chunk* unsorted_cache       |   |  |
|  |  +-------------------------------+   |  |
|  |                                      |  |
|  |          Sorted Cache                |  |
|  |                                      |  |
|  |  +-------------------------------+   |  |
|  |  | t_hash* sorted_cache          |   |  |
|  |  +-------------------------------+   |  |
|  +--------------------------------------+  |
|                                            |
+--------------------------------------------+
                |         ^
                |         |
                v         |
+--------------------------------------------+
|              Backend Pageheap              |
|                                            |
|  +--------------------------------------+  |
|  | Span Organization:                   |  |
|  | - Spans allocated with mmap()        |  |
|  | - Pages within spans                 |  |
|  | - Pagemap structure                  |  |
|  +--------------------------------------+  |
|                                            |
|  +--------------------------------------+  |
|  | Dynamic Page Movement:               |  |
|  | - Move pages based on usage patterns |  |
|  +--------------------------------------+  |
|                                            |
+--------------------------------------------+
                |         ^
                |         |
                v         |
+--------------------------------------------+
|               Operating System             |
|                                            |
|  +--------------------------------------+  |
|  |  Memory Allocation:                  |  |
|  |  - Direct allocation for huge sizes  |  |
|  |    (larger than 4KB) using mmap()    |  |
|  +--------------------------------------+  |
|                                            |
+--------------------------------------------+


Frontend Cache (detailed):
Summary
    Fast Cache Array: 
    Quick access to small allocations using a simple array and singly linked lists (t_tiny_chunk).

    Unsorted Cache: 
    Temporary storage for recently freed chunks, organized as a singly linked list (t_chunk).  

    Sorted Cache: 
    Efficient management of small and large allocations using a hash table and doubly linked lists (t_chunk).

+---------------------------+
|        Fast Cache         |
|                           |
|  +-----------+            |
|  | [0]       | --> NULL   |
|  +-----------+            |
|  | [1]       | --> +------------+     +------------+     +------------+ 
|  +-----------+     |t_tiny_chunk|-->  |t_tiny_chunk|-->  |t_tiny_chunk|--> NULL
|  | [2]       |     +------------+     +------------+     +------------+ 
|  +-----------+            |
|  | [3]       | --> NULL   |
|  +-----------+            |
|  | [4]       | --> NULL   |
|  +-----------+     +------------+ 
|  | ...       |     | ...        | 
|  +-----------+     +------------+ 
|                           |
+---------------------------+

+---------------------------+
|      Unsorted Cache       |
|                           |
|  +----------+      +----------+          
|  | t_chunk  | -->  | t_chunk  | --> NULL   
|  +----------+      +----------+         
|                           |
+---------------------------+


+---------------------------+
|       Sorted Cache        |
|                           |
|  +-----------+            |
|  | [0]       | --> NULL   |
|  +-----------+            |
|  | [1]       | --> +----------+     +----------+     +----------+ 
|  +-----------+     | t_chunk  |<--> | t_chunk  |<--> |  t_chunk |<--> NULL
|  | [2]       |     +----------+     +----------+     +----------+ 
|  +-----------+            |
|  | ...       |            |
|  +-----------+     +----------+     +----------+ 
|  | [N]       | --> | t_chunk  |<--> | t_chunk  |<--> NULL
|  +-----------+     +----------+     +----------+ 
|                           |
+---------------------------+


Chunk Header Metadata
Each chunk has a header that includes metadata necessary for managing memory. For free chunks, this header includes:

Size and Status:
The size of the chunk, including a flag indicating whether it is free or allocated.
Previous Size:
The size of the previous chunk, which is particularly useful when the current chunk is free, allowing backward traversal.
Tracking Adjacent Chunks
PtMalloc uses the following methods to track adjacent chunks:

Boundary Tags:

At the end of each chunk, ptmalloc writes a boundary tag that replicates the size of the chunk. This allows the allocator to quickly find the start of the next chunk by adding the size of the current chunk to its starting address.
When coalescing, the allocator can easily find the previous chunk using the previous size field and the next chunk using the current chunk’s size.
In-Place Headers:

When a chunk is freed, the allocator uses the size and previous size fields to check the status of adjacent chunks. If neighboring chunks are also free, it can coalesce them by updating their headers appropriately.
Example of Adjacent Chunk Tracking
Let's consider three contiguous chunks in memory:


[Chunk A (allocated)]
+------------------+
| Size             |
| ...              |
+------------------+
| User Data        |
+------------------+

[Chunk B (free)]
+------------------+
| Size             | <- includes a flag indicating free
| Prev Size        | <- size of Chunk A
| FD -> Chunk C    |
| BK -> Bin Head   |
+------------------+
| ...              |
+------------------+
| Boundary Tag     | <- size of Chunk B
+------------------+

[Chunk C (free)]
+------------------+
| Size             |
| Prev Size        | <- size of Chunk B
| FD -> Bin Tail   | <- NULL 
| BK -> Chunk B    |
+------------------+
| ...              |
+------------------+
| Boundary Tag     | <- size of Chunk C
+------------------+


[Chunk Header]
+---------------------+
| Size                |  <- Contains the size of the chunk and a status bit (allocated/free)
| Previous Size       |  <- Size of the previous chunk in memory
| FD (Forward Pointer)|  <- Pointer to the next free chunk in the bin list
| BK (Backward Pointer)| <- Pointer to the previous free chunk in the bin list
+---------------------+
| ...                 |  <- User data or unused space
+---------------------+
| Boundary Tag (Size) |  <- Copy of the size field from the chunk header
+---------------------+


Writing the Boundary Tag
The boundary tag is written into the chunk structure when a chunk is freed. Here’s how ptmalloc writes the boundary tag:

Determine the Boundary Tag Location:

The boundary tag is placed at the end of the chunk. To find this location, ptmalloc adds the chunk’s size to the chunk’s starting address.
Note that the size includes the metadata and the user data sections of the chunk.
Write the Size:

PtMalloc writes the size of the chunk (the same value as in the size field of the chunk header) into the location determined in step 1.
Example
Consider a chunk of size 0x40 bytes (64 bytes). This size includes the metadata and user data. Here’s a more detailed example:

Chunk Header:

Size: 0x40 (the size includes the chunk’s header and user data).
Previous Size: (size of the previous chunk).
FD: (pointer to the next free chunk in the bin list).
BK: (pointer to the previous free chunk in the bin list).

Boundary Tag:

The boundary tag is placed at the end of the chunk, which is at the address (chunk start address + 0x40 - size of the boundary tag).

Simplified Memory Layout:

0x0000: [Size: 0x40]              <- Start of the chunk
0x0008: [Previous Size: ...]
0x0010: [FD: ...]
0x0018: [BK: ...]
0x0020: [User Data or unused space]
...
0x0038: [Boundary Tag: 0x40]      <- End of the chunk (Size of the boundary tag is typically 8 bytes)

Summary
Header: Contains the size, previous size, and pointers for the free list.
Boundary Tag: A copy of the size field, written at the end of the chunk.
Coalescing: Boundary tags allow quick access to the previous chunk, facilitating efficient coalescing.


Simplified Memory Allocator Example
Chunk Structure Definition
First, we define the chunk structure with the necessary fields:
In this example, we don't really need two separate structs for `chunk` and `chunk_header`. We can combine them into a single struct that includes all necessary fields. This will simplify the code and reduce redundancy.

Here’s a revised version of the code with a single `chunk` struct:

### Simplified Memory Allocator Example with a Single Chunk Struct

#### Chunk Structure Definition
First, we define the chunk structure with the necessary fields:

```c

typedef struct chunk {
    size_t size;          // Size of the chunk (includes the size of the header)
    size_t prev_size;     // Size of the previous chunk
    struct chunk* fd;     // Forward pointer for the free list
    struct chunk* bk;     // Backward pointer for the free list
} chunk;

// Helper macros to access boundary tags
#define CHUNK_SIZE(chunk) ((chunk)->size & ~0x7) // Mask out lower bits used for status
#define NEXT_CHUNK(chunk) ((chunk*)((char*)(chunk) + CHUNK_SIZE(chunk)))
#define PREV_CHUNK(chunk) ((chunk*)((char*)(chunk) - (chunk)->prev_size))

// Alignment to ensure proper boundaries
#define ALIGN_SIZE 8
#define ALIGN_MASK (ALIGN_SIZE - 1)
#define ALIGN(n) (((n) + ALIGN_MASK) & ~ALIGN_MASK)

#define CHUNK_OVERHEAD sizeof(size_t) // Simplified, normally includes additional metadata
#define MIN_CHUNK_SIZE (sizeof(chunk) + CHUNK_OVERHEAD)
```

#### Functions to Write Boundary Tag and Free Chunks
Next, we implement the functions to free a chunk, write a boundary tag, and coalesce adjacent free chunks:

```c
// Function to write boundary tag
void write_boundary_tag(chunk* ch) {
    size_t* boundary_tag = (size_t*)((char*)ch + CHUNK_SIZE(ch) - sizeof(size_t));
    *boundary_tag = ch->size;
}

// Function to free a chunk and coalesce if possible
void free_chunk(chunk* ch) {
    chunk* next_chunk = NEXT_CHUNK(ch);

    // Coalesce with next chunk if it's free
    if (!(next_chunk->size & 1)) { // Check if next chunk is free
        ch->size += CHUNK_SIZE(next_chunk);
        next_chunk = NEXT_CHUNK(ch);
    }

    // Write the boundary tag
    write_boundary_tag(ch);

    // Coalesce with previous chunk if it's free
    if (!(ch->prev_size & 1)) { // Check if previous chunk is free
        chunk* prev_chunk = PREV_CHUNK(ch);
        prev_chunk->size += CHUNK_SIZE(ch);
        ch = prev_chunk;

        // Write the boundary tag
        write_boundary_tag(ch);
    }

    // Insert chunk into the free list (simplified for this example)
    ch->fd = free_list;
    if (free_list) {
        free_list->bk = ch;
    }
    free_list = ch;
}

// Simplified global free list for demonstration purposes
chunk* free_list = NULL;
```

#### Usage Example
Here's how you might use these functions in a simple program:

```c
int main() {
    // Simulate allocation of a chunk (simplified)
    size_t chunk_size = ALIGN(100); // Requested size
    chunk* ch = (chunk*)malloc(chunk_size + sizeof(chunk));
    ch->size = chunk_size | 1; // Mark as allocated
    ch->prev_size = 0; // No previous chunk in this example

    // Simulate freeing the chunk
    ch->size &= ~1; // Mark as free
    free_chunk(ch);

    // For demonstration purposes, print the size and boundary tag
    printf("Chunk size: %zu\n", ch->size);
    size_t* boundary_tag = (size_t*)((char*)ch + CHUNK_SIZE(ch) - sizeof(size_t));
    printf("Boundary tag: %zu\n", *boundary_tag);

    free(ch); // Clean up
    return 0;
}
```

### Explanation
- **Chunk Structure**: The `chunk` struct includes the size, previous size, and pointers for the free list.
- **Helper Macros**: Macros to calculate the size and find the next and previous chunks.
- **Functions**: Implementations for writing the boundary tag, freeing a chunk, and coalescing adjacent free chunks.
- **Usage Example**: Demonstrates allocation, freeing, and boundary tag checking.
